// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package pgquery

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCaseUpdates = `-- name: GetCaseUpdates :many
SELECT update_date, update_details FROM case_update WHERE cnj = $1 ORDER BY update_date DESC
`

type GetCaseUpdatesRow struct {
	UpdateDate    pgtype.Timestamptz
	UpdateDetails string
}

func (q *Queries) GetCaseUpdates(ctx context.Context, cnj string) ([]GetCaseUpdatesRow, error) {
	rows, err := q.db.Query(ctx, getCaseUpdates, cnj)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCaseUpdatesRow
	for rows.Next() {
		var i GetCaseUpdatesRow
		if err := rows.Scan(&i.UpdateDate, &i.UpdateDetails); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourtCase = `-- name: GetCourtCase :one
SELECT id, cnj, plaintiff, defendant, court_of_origin, start_date, created_at from court_case WHERE cnj = $1 LIMIT 1
`

func (q *Queries) GetCourtCase(ctx context.Context, cnj string) (CourtCase, error) {
	row := q.db.QueryRow(ctx, getCourtCase, cnj)
	var i CourtCase
	err := row.Scan(
		&i.ID,
		&i.Cnj,
		&i.Plaintiff,
		&i.Defendant,
		&i.CourtOfOrigin,
		&i.StartDate,
		&i.CreatedAt,
	)
	return i, err
}

const insertCaseUpdate = `-- name: InsertCaseUpdate :exec
INSERT INTO case_update (
	cnj, update_date, update_details
) VALUES (
	$1, $2, $3
)
`

type InsertCaseUpdateParams struct {
	Cnj           string
	UpdateDate    pgtype.Timestamptz
	UpdateDetails string
}

func (q *Queries) InsertCaseUpdate(ctx context.Context, arg InsertCaseUpdateParams) error {
	_, err := q.db.Exec(ctx, insertCaseUpdate, arg.Cnj, arg.UpdateDate, arg.UpdateDetails)
	return err
}

const insertCourtCase = `-- name: InsertCourtCase :one
INSERT INTO court_case (
	cnj, plaintiff, defendant, court_of_origin, start_date
) VALUES (
	$1, $2, $3, $4, $5
)
RETURNING cnj
`

type InsertCourtCaseParams struct {
	Cnj           string
	Plaintiff     string
	Defendant     string
	CourtOfOrigin string
	StartDate     pgtype.Date
}

func (q *Queries) InsertCourtCase(ctx context.Context, arg InsertCourtCaseParams) (string, error) {
	row := q.db.QueryRow(ctx, insertCourtCase,
		arg.Cnj,
		arg.Plaintiff,
		arg.Defendant,
		arg.CourtOfOrigin,
		arg.StartDate,
	)
	var cnj string
	err := row.Scan(&cnj)
	return cnj, err
}
